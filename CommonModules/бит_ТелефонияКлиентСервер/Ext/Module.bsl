////////////////////////////////////////////////////////////////////////////////
// Общий модуль телефонии БИТ
// Содержит общие функции, которые могут вызываться на клиенте и на сервере.
////////////////////////////////////////////////////////////////////////////////

// Возвращает минимальную длину внешнего номера.
// Если номер длиннее данного значения, он считается внешним, иначе - внутренним.
//
// Возвращаемое значение:
//   Число - длина.
//
Функция ПолучитьДлинуВнешнегоНомера() ЭКСПОРТ
	Возврат 10;
КонецФункции

// Возвращает минимальную длину международного номера.
// Если номер длиннее данного значения, он считается международным.
//
// Международный номер в России начинается с кода "10" и имеет минимум 13 цифр,
// например: номер США 10-1 (305) 571-1200,
// номер Белоруссии 10-375 (17) 289-0000.
//
// Возвращаемое значение:
//   Число - длина.
//
Функция ПолучитьДлинуМеждународногоНомера() ЭКСПОРТ
	Возврат 13;
КонецФункции

// Получает индекс первого символа '*' или '#' в номере.
// Если символов '*' или '#' в номере нет, возвращается 0.
//
// Параметры:
//  стрНомер - Строка - номер телефона.
//
// Возвращаемое значение:
//   Целое число - индекс символа, начиная с 1.
//
Функция ПолучитьИндексЗвРеш(стрНомер) ЭКСПОРТ
	кодЗв	= 42;	// '*'
	кодРеш	= 35;	// '#'
	длинаНомера = СтрДлина(стрНомер);
	индРазд = 0;
	Для й=1 по длинаНомера Цикл
		кодСимв = КодСимвола(стрНомер, й);
		Если (кодСимв=кодЗв) ИЛИ (кодСимв=кодРеш) Тогда
			индРазд = й;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат индРазд;
КонецФункции

// Сокращает номер, убирая все префиксы.
//
// Параметры:
//  стрНомер  - Строка - номер телефона.
//
// Возвращаемое значение:
//   Строка - номер без префиксов.
//
Функция СократитьНомерДляПоиска(стрНомер) ЭКСПОРТ
	индексЗвРеш = ПолучитьИндексЗвРеш(стрНомер);
	Если индексЗвРеш > 0 Тогда
		Возврат стрНомер;
	КонецЕсли;
	//
	стрНомерДляПоиска = стрНомер;
	длинаНомера = СтрДлина(стрНомер);
	длинаВнешнегоНомера = ПолучитьДлинуВнешнегоНомера();
	Если длинаНомера > длинаВнешнегоНомера Тогда
		длинаМеждународногоНомера = ПолучитьДлинуМеждународногоНомера();
		Если длинаНомера < длинаМеждународногоНомера Тогда
			стрНомерДляПоиска = Прав(стрНомер, длинаВнешнегоНомера);
		Иначе
			индекс10 = Найти(стрНомер, "10");
			Если индекс10 > 0 Тогда
				// считаем что это международный номер
				стрНомерДляПоиска = Сред(стрНомер, индекс10);
			Иначе
				// непонятный формат номера, считаем что простой внешний
				стрНомерДляПоиска = Прав(стрНомер, длинаВнешнегоНомера);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат стрНомерДляПоиска;
КонецФункции

// Функция очистки, оставляет в строке номера только цифры от 0 до 9.
//
// Параметры:
//  стрНомер  - Строка - номер телефона.
//
// Возвращаемое значение:
//   Строка - очищенный номер.
//
Функция ОчиститьНомерТолькоЦифры(стрНомер) ЭКСПОРТ
	код0	= 48;
	код9	= 57;
	стрОчищНомер = "";
	длинаНомера = СтрДлина(стрНомер);
	Для й=1 по длинаНомера Цикл
		кодСимв = КодСимвола(стрНомер, й);
		Если (кодСимв >= код0 И кодСимв <= код9) Тогда
			стрОчищНомер = стрОчищНомер + Символ(кодСимв);
		КонецЕсли;
	КонецЦикла;
	Возврат стрОчищНомер;
КонецФункции

// Функция очистки, оставляет в строке номера цифры от 0 до 9, символы '*' и '#'.
//
// Параметры:
//  стрНомер  - Строка - номер телефона.
//
// Возвращаемое значение:
//   Строка - очищенный номер.
//
Функция ОчиститьНомерЦифрыЗвРеш(стрНомер) ЭКСПОРТ
	код0	= 48;	// '0'
	код9	= 57;	// '9'
	кодЗв	= 42;	// '*'
	кодРеш	= 35;	// '#'
	стрОчищНомер = "";
	длинаНомера = СтрДлина(стрНомер);
	Для й=1 по длинаНомера Цикл
		кодСимв = КодСимвола(стрНомер, й);
		Если (кодСимв >= код0 И кодСимв <= код9) ИЛИ (кодСимв=кодЗв) ИЛИ (кодСимв=кодРеш) Тогда
			стрОчищНомер = стрОчищНомер + Символ(кодСимв);
		КонецЕсли;
	КонецЦикла;
	Возврат стрОчищНомер;
КонецФункции

// Переводит длительность звонка из секунд в строку.
//
// Параметры:
//  Длительность - Число (целое), длительность в секундах.
//
// Возвращаемое значение:
//   Строка  - длительность в формате '00:00:00'.
//
Функция ФорматироватьДлительностьЗвонкаСЛидНулями(Длительность) ЭКСПОРТ
	длитМин = Цел(Длительность / 60);
	длитСек = Длительность % 60;
	длитЧас = Цел(длитМин / 60);
	длитМин = длитМин % 60;
	стрФорматаСЛидНулем = "ЧЦ=2; ЧН=; ЧВН=";
	стрДлительность = Строка(длитЧас) + ":" + Формат(длитМин, стрФорматаСЛидНулем) + ":" + Формат(длитСек, стрФорматаСЛидНулем);
	Возврат стрДлительность;
КонецФункции

////////////////////////////////////////////////////////////////////////////////

// Разбивает строку с разделителями, возвращает список значений.
//
// Параметры:
//  стрРазбор - Строка, строка для разбора,
//  стрРазделитель - Строка, разделитель.
//
// Возвращаемое значение:
//   СписокЗначений  - список подстрок.
//
Функция СтрРазбить(Знач стрРазбор, стрРазделитель) ЭКСПОРТ
	список = Новый СписокЗначений;
	длинаРазделителя = СтрДлина(стрРазделитель);
	поз = Найти(стрРазбор, стрРазделитель);
	Пока поз > 0 Цикл
		стрПодстрока = Лев(стрРазбор, поз-1);
		список.Добавить(стрПодстрока);
		стрРазбор = Сред(стрРазбор, поз+длинаРазделителя);
		поз = Найти(стрРазбор, стрРазделитель);
	КонецЦикла;
	Если СтрДлина(стрРазбор) <> 0 Тогда
		список.Добавить(стрРазбор);
	КонецЕсли;
	Возврат список;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с JSON

// Разбор JSON
//
// Параметры:
//   ТекстJSON - Строка - текст для разбора.
//
// Возвращаемое значение:
//   Соответствие - результат разбора.
//
Функция ЗаполнитьСоответствиеИзJSON(Знач ТекстJSON) ЭКСПОРТ
	//
	// версия разбора для платформы 8.3.6 и выше
	//чтение = Новый ЧтениеJSON();
	//чтение.УстановитьСтроку(ТекстJSON);
	//Результат = ПрочитатьJSON(чтение, Истина);
	//
	Результат = Новый Соответствие;
	
	ТекстJSON = СтрЗаменить(ТекстJSON, "\""", " ");
	Если Лев(ТекстJSON, 1) = "{" Тогда
		ЗаполнитьДанныеИзОтветаJSON(Результат, ТекстJSON, "Структура");
	ИначеЕсли Лев(ТекстJSON, 1) = "[" Тогда
		МассивДанных = Новый Массив;
		ЗаполнитьДанныеИзОтветаJSON(МассивДанных, ТекстJSON, "Массив");
		
		Результат.Вставить("Значение", МассивДанных);
	КонецЕсли;
		
	Возврат Результат;
КонецФункции

Функция ПолучитьТокенJSON(ТекстJSON, флагПрервать)
	
	Токен = "";
	
	Поз = Найти(ТекстJSON, """");
	Если Поз = 0 Тогда
		флагПрервать = Истина;
		Возврат Токен;
	КонецЕсли;
	
	ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз+1));
	
	Поз = Найти(ТекстJSON, """");
	Если Поз = 0 Тогда
		флагПрервать = Истина;
		Возврат Токен;
	КонецЕсли;
	
	Токен = СокрЛП(Лев(ТекстJSON, Поз-1));
	ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз+1));
	
	Возврат Токен;
КонецФункции

Процедура ЗаполнитьДанныеИзОтветаJSON(Результат, ТекстJSON, ТипДанных)
	ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));	
	НомерЗначения = 0;
	
	Пока ТекстJSON <> "" Цикл
		ПервыйСимвол = Лев(ТекстJSON, 1);
		Если ПервыйСимвол = "{" Тогда
			Значение = Новый Соответствие;
			ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Структура");
			
			Если ТипДанных = "Структура" Тогда
				Результат.Вставить("Значение" + ?(НомерЗначения = 0, "", НомерЗначения), Значение);
				НомерЗначения = НомерЗначения + 1;
			ИначеЕсли ТипДанных = "Массив" Тогда
				Результат.Добавить(Значение);
			КонецЕсли;
		ИначеЕсли ПервыйСимвол = "[" Тогда
			Значение = Новый Массив;
			ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Массив");
			
			Если ТипДанных = "Структура" Тогда
				Результат.Вставить("Значение" + ?(НомерЗначения = 0, "", НомерЗначения), Значение);
				НомерЗначения = НомерЗначения + 1;
			Иначе
				Результат.Добавить(Значение);
			КонецЕсли;
		ИначеЕсли ПервыйСимвол = "}" И ТипДанных = "Структура" Тогда
			ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			Если Лев(ТекстJSON, 1) = "," Тогда
				ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			КонецЕсли;
			
			Возврат;
		ИначеЕсли ПервыйСимвол = "]" И ТипДанных = "Массив" Тогда
			ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			Если Лев(ТекстJSON, 1) = "," Тогда
				ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			КонецЕсли;
			
			Возврат;
		Иначе
			Если ТипДанных = "Структура" Тогда
				
				флагПрервать = Ложь;
				ИмяЗначения = ПолучитьТокенJSON(ТекстJSON, флагПрервать);
				Если флагПрервать Тогда
					Прервать;
				КонецЕсли;
				
				Поз = Найти(ТекстJSON, ":");
				Если Поз = 0 Тогда
					Прервать;
				КонецЕсли;
				
				ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз+1));
				
				Если Лев(ТекстJSON, 1) = "{" Тогда
					Значение = Новый Соответствие;
					ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Структура");
				ИначеЕсли Лев(ТекстJSON, 1) = "[" Тогда
					Значение = Новый Массив;
					ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Массив");
				Иначе
					флагПрервать = Ложь;
					Значение = ПолучитьТокенJSON(ТекстJSON, флагПрервать);
					
					Если флагПрервать Тогда
						Значение = ТекстJSON;
						ТекстJSON = "";
					Иначе
						Символ = Лев(ТекстJSON, 1);
						Если Символ = "," Тогда
							ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
						КонецЕсли;
					КонецЕсли;
					
				КонецЕсли;
				
				Результат.Вставить(ИмяЗначения, Значение);
				
			ИначеЕсли ТипДанных = "Массив" Тогда
				
				флагПрервать = Ложь;
				Значение = ПолучитьТокенJSON(ТекстJSON, флагПрервать);
				
				Если флагПрервать Тогда
					Значение = ТекстJSON;
					ТекстJSON = "";
				Иначе
					Символ = Лев(ТекстJSON, 1);
					Если Символ = "," Тогда
						ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
					КонецЕсли;
				КонецЕсли;
					
				Результат.Добавить(Значение);
				
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

