
Функция ПолучитьЗначенияРеквизитовОбъекта(Ссылка, СтруктураПолей) Экспорт

	Результат = Новый Структура;
	Для Каждого КлючИЗначение ИЗ СтруктураПолей Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;

	ТекстЗапроса = "";
	
	ОбъектМетаданных = Ссылка.Метаданные();

	Для Каждого Элемент Из СтруктураПолей Цикл
		
		ИмяПоля = Элемент.Значение;
		
		Если НЕ ЗначениеЗаполнено(ИмяПоля) Тогда
			ИмяПоля = СокрЛП(Элемент.Ключ);
		КонецЕсли;
		
		ТекстЗапроса  = ТекстЗапроса + ?(ПустаяСтрока(ТекстЗапроса), "", ",") + "
		|	" + ИмяПоля + " КАК " + СокрЛП(Элемент.Ключ);
	КонецЦикла;

	Запрос = Новый Запрос();

	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ" + ТекстЗапроса + "
	|ИЗ
	|	" + ОбъектМетаданных.ПолноеИмя() + " КАК ТаблицаОбъекта
	|ГДЕ
	|	Ссылка = &Ссылка";

	Запрос.УстановитьПараметр("Ссылка" , Ссылка);

	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Для Каждого КлючИЗначение ИЗ СтруктураПолей Цикл
			Результат[КлючИЗначение.Ключ] = Выборка[КлючИЗначение.Ключ];
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

// Проверяет соответствие ИНН требованиям.
//
// Параметры:
//  ИНН          - Строка - Проверяемый индивидуальный номер налогоплательщика.
//  ЮрФизЛицо    - ПеречислениеСсылка.ЮрФизЛицо - Тип владельца ИНН: физлицо или юрлицо.
//  ТекстСообщения - Строка - Текст сообщения о найденных ошибках.
//
// Возвращаемое значение:
//  Истина       - ИНН соответствует требованиям;
//  Ложь         - ИНН не соответствует требованиям.
//
Функция ИННСоответствуетТребованиям(Знач ИНН, ЮрФизЛицо, Текстсообщения) Экспорт

	СоответствуетТребованиям = Истина;
	ТекстСообщения = "";

	ИНН = СокрЛП(ИНН);
	ДлинаИНН = СтрДлина(ИНН);

	Если НЕ УдалитьСтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ИНН) Тогда
		СоответствуетТребованиям = Ложь;
		ТекстСообщения = ТекстСообщения + НСтр("ru = 'ИНН должен состоять только из цифр.'");
	КонецЕсли;

	Если ЮрФизЛицо = Справочники.ЮрФизЛицо.ЮрЛицо И ДлинаИНН <> 10 Тогда
		СоответствуетТребованиям = Ложь;
		ТекстСообщения = ТекстСообщения + ?(ЗначениеЗаполнено(ТекстСообщения), Символы.ПС, "")
		               + НСтр("ru = 'ИНН юридического лица должен состоять из 10 цифр.'");
	ИначеЕсли ЮрФизЛицо = Справочники.ЮрФизЛицо.ФизЛицо И ДлинаИНН <> 12 Тогда
		СоответствуетТребованиям = Ложь;
		ТекстСообщения = ТекстСообщения + ?(ЗначениеЗаполнено(ТекстСообщения), Символы.ПС, "")
		               + НСтр("ru = 'ИНН физического лица должен состоять из 12 цифр.'");
	КонецЕсли;

	Если СоответствуетТребованиям Тогда

		Если ЮрФизЛицо = Справочники.ЮрФизЛицо.ЮрЛицо Тогда

			КонтрольнаяСумма = 0;

			Для Н = 1 По 9 Цикл

				Если Н = 1 Тогда
					Множитель = 2;
				ИначеЕсли Н = 2 Тогда
					Множитель = 4;
				ИначеЕсли Н = 3 Тогда
					Множитель = 10;
				ИначеЕсли Н = 4 Тогда
					Множитель = 3;
				ИначеЕсли Н = 5 Тогда
					Множитель = 5;
				ИначеЕсли Н = 6 Тогда
					Множитель = 9;
				ИначеЕсли Н = 7 Тогда
					Множитель = 4;
				ИначеЕсли Н = 8 Тогда
					Множитель = 6;
				ИначеЕсли Н = 9 Тогда
					Множитель = 8;
				КонецЕсли;

				Цифра = Число(Сред(ИНН, Н, 1));
				КонтрольнаяСумма = КонтрольнаяСумма + Цифра * Множитель;

			КонецЦикла;
			
			КонтрольныйРазряд = (КонтрольнаяСумма %11) %10;

			Если КонтрольныйРазряд <> Число(Сред(ИНН, 10, 1)) Тогда
				СоответствуетТребованиям = Ложь;
				ТекстСообщения = ТекстСообщения + ?(ЗначениеЗаполнено(ТекстСообщения), Символы.ПС, "")
				               + НСтр("ru = 'Контрольное число для ИНН не совпадает с рассчитанным.'");
			КонецЕсли;

		Иначе

			КонтрольнаяСумма11 = 0;
			КонтрольнаяСумма12 = 0;

			Для Н=1 По 11 Цикл

				// Расчет множителя для 11-го и 12-го разрядов
				Если Н = 1 Тогда
					Множитель11 = 7;
					Множитель12 = 3;
				ИначеЕсли Н = 2 Тогда
					Множитель11 = 2;
					Множитель12 = 7;
				ИначеЕсли Н = 3 Тогда
					Множитель11 = 4;
					Множитель12 = 2;
				ИначеЕсли Н = 4 Тогда
					Множитель11 = 10;
					Множитель12 = 4;
				ИначеЕсли Н = 5 Тогда
					Множитель11 = 3;
					Множитель12 = 10;
				ИначеЕсли Н = 6 Тогда
					Множитель11 = 5;
					Множитель12 = 3;
				ИначеЕсли Н = 7 Тогда
					Множитель11 = 9;
					Множитель12 = 5;
				ИначеЕсли Н = 8 Тогда
					Множитель11 = 4;
					Множитель12 = 9;
				ИначеЕсли Н = 9 Тогда
					Множитель11 = 6;
					Множитель12 = 4;
				ИначеЕсли Н = 10 Тогда
					Множитель11 = 8;
					Множитель12 = 6;
				ИначеЕсли Н = 11 Тогда
					Множитель11 = 0;
					Множитель12 = 8;
				КонецЕсли;

				Цифра = Число(Сред(ИНН, Н, 1));
				КонтрольнаяСумма11 = КонтрольнаяСумма11 + Цифра * Множитель11;
				КонтрольнаяСумма12 = КонтрольнаяСумма12 + Цифра * Множитель12;

			КонецЦикла;

			КонтрольныйРазряд11 = (КонтрольнаяСумма11 %11) %10;
			КонтрольныйРазряд12 = (КонтрольнаяСумма12 %11) %10;

			Если КонтрольныйРазряд11 <> Число(Сред(ИНН,11,1)) ИЛИ КонтрольныйРазряд12 <> Число(Сред(ИНН,12,1)) Тогда
				СоответствуетТребованиям = Ложь;
				ТекстСообщения = ТекстСообщения + ?(ЗначениеЗаполнено(ТекстСообщения), Символы.ПС, "")
				               + НСтр("ru = 'Контрольное число для ИНН не совпадает с рассчитанным.'");
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	Возврат СоответствуетТребованиям;

КонецФункции // ИННСоответствуетТребованиям()

// Проверяет соответствие КПП требованиям.
//
// Параметры:
//  КПП          - Строка - Проверяемый код причины постановки на учет.
//  ТекстСообщения - Строка - Текст сообщения о найденных ошибках.
//
// Возвращаемое значение:
//  Истина       - КПП соответствует требованиям;
//  Ложь         - КПП не соответствует требованиям.
//
Функция КППСоответствуетТребованиям(Знач КПП, ТекстСообщения) Экспорт

	СоответствуетТребованиям = Истина;
	ТекстСообщения           = "";

	КПП      = СокрЛП(КПП);
	ДлинаКПП = СтрДлина(КПП);

	Если НЕ УдалитьСтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(КПП) Тогда
		СоответствуетТребованиям = Ложь;
		ТекстСообщения = ТекстСообщения + НСтр("ru = 'КПП должен состоять только из цифр.'");
	КонецЕсли;

	Если ДлинаКПП <> 9 Тогда
		СоответствуетТребованиям = Ложь;
		ТекстСообщения = ТекстСообщения + ?(ЗначениеЗаполнено(ТекстСообщения), Символы.ПС, "") +
			НСтр("ru = 'КПП должен состоять из 9 цифр.'");
	КонецЕсли;

	Возврат СоответствуетТребованиям;

КонецФункции // КППСоответствуетТребованиям()

// Проверяет соответствие ОГРН требованиям.
//
// Параметры:
//  ОГРН         - Строка - Проверяемый основной государственный регистрационный номер.
//  ЮрФизЛицо    - ПеречислениеСсылка.ЮрФизЛицо - Тип владельца ИНН: физлицо или юрлицо.
//  ТекстСообщения - Строка - Текст сообщения о найденных ошибках.
//
// Возвращаемое значение:
//  Истина       - ОГРН соответствует требованиям;
//  Ложь         - ОГРН не соответствует требованиям.
//
Функция ОГРНСоответствуетТребованиям(Знач ОГРН, ЮрФизЛицо, Текстсообщения) Экспорт

	СоответствуетТребованиям = Истина;
	ТекстСообщения = "";

	ОГРН = СокрЛП(ОГРН);
	ДлинаОГРН = СтрДлина(ОГРН);

	Если НЕ УдалитьСтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ОГРН) Тогда
		СоответствуетТребованиям = Ложь;
		ТекстСообщения = ТекстСообщения + НСтр("ru = 'ОГРН должен состоять только из цифр.'")
	КонецЕсли;

	Если ЮрФизЛицо = Справочники.ЮрФизЛицо.ЮрЛицо И ДлинаОГРН <> 13 Тогда
		СоответствуетТребованиям = Ложь;
		ТекстСообщения = ТекстСообщения + ?(ЗначениеЗаполнено(ТекстСообщения), Символы.ПС, "")
		               + НСтр("ru = 'ОГРН юридического лица должен состоять из 13 цифр.'");
	ИначеЕсли ЮрФизЛицо = Справочники.ЮрФизЛицо.ФизЛицо И ДлинаОГРН <> 15 Тогда
		СоответствуетТребованиям = Ложь;
		ТекстСообщения = ТекстСообщения + ?(ЗначениеЗаполнено(ТекстСообщения), Символы.ПС, "")
		               + НСтр("ru = 'ОГРН физического лица должен состоять из 15 цифр.'");
	КонецЕсли;

	Если СоответствуетТребованиям Тогда

		Если ЮрФизЛицо = Справочники.ЮрФизЛицо.ЮрЛицо Тогда

			КонтрольныйРазряд = Прав(Формат(Число(Лев(ОГРН, 12)) % 11, "ЧН=0; ЧГ=0"), 1);

			Если КонтрольныйРазряд <> Прав(ОГРН, 1) Тогда
				СоответствуетТребованиям = Ложь;
				ТекстСообщения = ТекстСообщения + ?(ЗначениеЗаполнено(ТекстСообщения), Символы.ПС, "")
				               + НСтр("ru = 'Контрольное число для ОГРН не совпадает с рассчитанным.'");
			КонецЕсли;

		Иначе

			КонтрольныйРазряд = Прав(Формат(Число(Лев(ОГРН, 14)) % 13, "ЧН=0; ЧГ=0"), 1);

			Если КонтрольныйРазряд <> Прав(ОГРН, 1) Тогда
				СоответствуетТребованиям = Ложь;
				ТекстСообщения = ТекстСообщения + ?(ЗначениеЗаполнено(ТекстСообщения), Символы.ПС, "")
				               + НСтр("ru = 'Контрольное число для ОГРН не совпадает с рассчитанным.'");
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	Возврат СоответствуетТребованиям;

КонецФункции // ИННСоответствуетТребованиям()

//Проверяет наличие строк в масссиве, если есть то выдаёт сообщения.
//
// Параметры:
//		МассивОшибок - массив;
//	    ТекстОшибки  - строка;
//      ИмяРеквизита  - имя реквизита.
//
// Возвращаемое значение:
//  булево.
//	
Функция СообщениеНеКорректности(МассивОшибок, ТекстОшибки, ИмяРеквизита = Неопределено) Экспорт
	
	Если МассивОшибок.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для каждого Ошибка из МассивОшибок Цикл
		Попытка
			НомерСтроки = "Строка " + Ошибка.НомерСтроки + ": ";
		Исключение
			НомерСтроки = "";
		КонецПопытки;
		Сообщить(НомерСтроки + ТекстОшибки + ?(ИмяРеквизита = Неопределено, "", Ошибка[ИмяРеквизита]), 
		СтатусСообщения.ОченьВажное);
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции   //СообщениеНеКорректности()

// Сравнивает таблицы наборов записей.
//
// Параметры:
//		ТаблицаЗначений1 - таблица значений;
//      ТаблицаЗначений2 - таблица значений.
//
// Возвращаемое значение:
//  булево.
//	
Функция СравнитьТаблицыНаборовЗаписей(ТаблицаЗначений1, ТаблицаЗначений2) Экспорт
	
	Если ТипЗнч(ТаблицаЗначений1) <> Тип("ТаблицаЗначений") ИЛИ ТипЗнч(ТаблицаЗначений2) <> Тип("ТаблицаЗначений") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Если ТаблицаЗначений1.Количество() <> ТаблицаЗначений2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Если ТаблицаЗначений1.Колонки.Количество() <> ТаблицаЗначений2.Колонки.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверим поля
	Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
		Если ТаблицаЗначений2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла; 
	Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
		Если ТаблицаЗначений1.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла; 
	
	// создадим индексы таблицы для поиска
	СтрокаИндекса = "";
	Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
		Если СтрокаИндекса = "" Тогда
			СтрокаИндекса = Колонка.Имя;
		Иначе
			СтрокаИндекса = СтрокаИндекса + "," + Колонка.Имя;
		КонецЕсли;
	КонецЦикла;
	Если СтрокаИндекса<>"" Тогда
		ТаблицаЗначений2.Индексы.Добавить(СтрокаИндекса);
	КонецЕсли;
	
	// Проверим записи
	Для каждого СтрокаТаблицы Из ТаблицаЗначений1 Цикл
		СтруктураПоиска = Новый Структура;
		Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
			СтруктураПоиска.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
		КонецЦикла;
		СтрокиТаблицы2 = ТаблицаЗначений2.НайтиСтроки(СтруктураПоиска);
		Если СтрокиТаблицы2.Количество() <> 1 Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла;
	
	// создадим индексы таблицы для поиска
	СтрокаИндекса = "";
	Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
		Если СтрокаИндекса = "" Тогда
			СтрокаИндекса = Колонка.Имя;
		Иначе
			СтрокаИндекса = СтрокаИндекса + "," + Колонка.Имя;
		КонецЕсли;
	КонецЦикла;
	Если СтрокаИндекса<>"" Тогда
		ТаблицаЗначений1.Индексы.Добавить(СтрокаИндекса);
	КонецЕсли;
	
	Для каждого СтрокаТаблицы Из ТаблицаЗначений2 Цикл
		СтруктураПоиска = Новый Структура;
		Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
			СтруктураПоиска.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
		КонецЦикла;
		СтрокиТаблицы1 = ТаблицаЗначений1.НайтиСтроки(СтруктураПоиска);
		Если СтрокиТаблицы1.Количество() <> 1 Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // СравнитьТаблицыЗначений()

// Функция возвращает интервалы напоминаний.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  СписокЗначений.
//
Функция ПолучитьСписокИнтерваловНапоминания() Экспорт
	
	СписокИнтервалов = Новый СписокЗначений;
	СписокИнтервалов.Добавить(5*60,"5 мин.");
	СписокИнтервалов.Добавить(10*60,"10 мин.");
	СписокИнтервалов.Добавить(15*60,"15 мин.");
	СписокИнтервалов.Добавить(30*60,"30 мин.");
	СписокИнтервалов.Добавить(1*60*60,"1 час");
	СписокИнтервалов.Добавить(2*60*60,"2 часа");
	СписокИнтервалов.Добавить(4*60*60,"4 часа");
	СписокИнтервалов.Добавить(8*60*60,"8 часов");
	СписокИнтервалов.Добавить(1*24*60*60,"1 день");
	СписокИнтервалов.Добавить(2*24*60*60,"2 дня");
	СписокИнтервалов.Добавить(3*24*60*60,"3 дня");
	СписокИнтервалов.Добавить(4*24*60*60,"4 дня");
	СписокИнтервалов.Добавить(1*7*24*60*60,"1 неделя");
	Возврат СписокИнтервалов;
	
КонецФункции //ПолучитьСписокИнтерваловНапоминания()

// Удаляет отбор.
//
// Параметры:
//		Отбор - массив.
//
// Возвращаемое значение:
//  булево.
//	
Процедура СброситьОтбор(Отбор) Экспорт
	Пока Отбор.Количество() > 0 Цикл
		Отбор.Удалить(0);
	КонецЦикла;
КонецПроцедуры // СброситьОтбор()

// Функция формирует список элементов перечисления.
//
// Параметры:
// ИмяПеречисления - имя перечисления, как оно задано в конфигураторе.
//
// Возвращаемое значение:
// СписокЗначений - список элементов перечисления.
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт
	
	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;
	
КонецФункции // ПолучитьСписокЭлементовПеречисления()

// Функция проверяет наличие в строке только цифр.
//
// Параметры:
//   СтрокаПроверки - Строка для проверки только цифр;
//  УчитыватьЛидирующиеНули - булево;
//  УчитыватьПробелы  - булево
//
// Возвращаемое значение:
// Булево.
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 
	
	Возврат Истина;
	
КонецФункции    //ТолькоЦифрыВСтроке()

// Функция проверяет наличие в строке только цифр.
//
// Параметры:
// СтрокаПроверки - строка для проверки только цифр
//
// Возвращаемое значение:
// булево.
//
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт
	
	СписокКодовЧисел = Новый СписокЗначений;
	Для а = 48 По 57 Цикл
		СписокКодовЧисел.Добавить(а);
	КонецЦикла; 
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			Если СписокКодовЧисел.НайтиПоЗначению(КодСимвола(Сред(СтрокаПроверки, а, 1))) = Неопределено Тогда
				Возврат Истина;
			КонецЕсли; 
		КонецЦикла; 
		
	КонецЕсли; 
	
	Возврат Ложь;
	
КонецФункции //ЕстьНеЦифры()

// Функция определяет наличие хотя бы одной записи в регистре сведений.
//
// Параметры:
//  ИмяРегистра - строка.
//
// Возвращаемое значение:
//   Булево.
//
Функция ЕстьЗаписиВРегистреСведений(ИмяРегистра) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	РегСв.*
	|ИЗ
	|	РегистрСведений." + ИмяРегистра + " КАК РегСв";
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции  //ЕстьЗаписиВРегистреСведений()

// Добавляет строки таблицы источника в таблицу приемник, если по
//	графам структуры идентификации не находит такой строки.
//
// Параметры:
//  ТаблицаПриемник - таблица значений или табличная часть; 
//  ТаблицаИсточник - таблица значений или табличная часть.
//  ПараметрыИдентификации - массив, каждый элемент - строка, имя графы таблицы.
// 
Процедура ПрисоединитьТаблицу(ТаблицаПриемник, ТаблицаИсточник, ПараметрыИдентификации = Неопределено) Экспорт
	Для Каждого СтрокаИсточник Из ТаблицаИсточник Цикл
		СтруктураИдентификации = Новый Структура;
		Если ПараметрыИдентификации <> Неопределено Тогда
			Для Каждого Параметр Из ПараметрыИдентификации Цикл
				Попытка
					СтруктураИдентификации.Вставить(Параметр, СтрокаИсточник[Параметр]);
				Исключение
					//Сообщить(ОписаниеОшибки());
					//Возврат;
				КонецПопытки;
			КонецЦикла;		
			НайденныеСтроки = ТаблицаПриемник.НайтиСтроки(СтруктураИдентификации);
			Если НайденныеСтроки.Количество() > 0 Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		НоваяСтрокаПриемника = ТаблицаПриемник.Добавить();
		Для Каждого Колонка Из ТаблицаИсточник.Колонки Цикл
			Попытка
				НоваяСтрокаПриемника[Колонка.Имя] = СтрокаИсточник[Колонка.Имя];
			Исключение
			КонецПопытки;
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры // ПрисоединитьТаблицу()

// Преобразовывает дату из строки в тип Дата.
//
// Параметры:
//  СтрДата - строка - дата.
//
// Возвращаемое значение:
//   дата - типа Дата.
//
Функция ПреобразоватьДату(СтрДата) Экспорт
	
	Разделители = Новый Массив;
	Разделители.Добавить(" ");
	Разделители.Добавить(".");
	Разделители.Добавить(",");
	МассивПолученный = Новый Массив;
	НомерНачала = 1;
	Для НомерСимвола = 1 по СтрДлина(СтрДата) Цикл 
		СимволСтроки = Сред(СтрДата,НомерСимвола,1);
		Если Разделители.Найти(СимволСтроки)<>Неопределено или НомерСимвола = СтрДлина(СтрДата) Тогда
			Если НомерСимвола = СтрДлина(СтрДата) Тогда 
				Количество = НомерСимвола-НомерНачала+1;
			Иначе
				Количество = НомерСимвола-НомерНачала;
			КонецЕсли;
			Подстрока = (Сред(СтрДата,НомерНачала,Количество));
			Если Подстрока <> "" Тогда
				МассивПолученный.Добавить(Подстрока);
			КонецЕсли;
			НомерНачала=НомерСимвола+1;
		КонецЕсли;
		
	КонецЦикла;
	ПреобрДата = Дата('00010101');
	Если МассивПолученный.Количество()<>3 Тогда
		ПреобрДата = Дата('00010101');
	Иначе
	    Попытка
		Д = Число(МассивПолученный.Получить(0));
		Г = Число(МассивПолученный.Получить(2));
		Если СтрДлина(МассивПолученный.Получить(2)) = 2 Тогда
			ТекущийГод = Число(Сред(Год(ТекущаяДата()),4,3));
			Г=?(Г>ТекущийГод,1900+Г,2000+Г);
		КонецЕсли;
		М = ПолучитьМесяц(НРег(МассивПолученный.Получить(1)));
		
			ПреобрДата = Дата(Г,м,д);
		Исключение
			ПреобрДата = Дата('00010101');
		КонецПопытки;
	КонецЕсли;
	Возврат ПреобрДата;
	
КонецФункции     //ПреобразоватьДату()

// Получает номер месяца.
//
// Параметры:
// Мес - месяц - число или строка.
//
// Возвращаемое значение:
//   номер месяца - число.
//
Функция ПолучитьМесяц(Мес)
	Январь = Новый Массив;
	Январь.Добавить("январь");
	Январь.Добавить("января");
	Январь.Добавить("янв");
	Февраль = Новый Массив;
	Февраль.Добавить("февраль");
	Февраль.Добавить("февраля");
	Февраль.Добавить("февр");
	Февраль.Добавить("фев");
	Март = Новый Массив;
	Март.Добавить("март");
	Март.Добавить("марта");
	Март.Добавить("мар");
	Апрель = Новый Массив;
	Апрель.Добавить("апрель");
	Апрель.Добавить("апреля");
	Апрель.Добавить("апр");
	Май = Новый Массив;
	Май.Добавить("май");
	Май.Добавить("мая");
	Июнь = Новый Массив;
	Июнь.Добавить("июнь");
	Июнь.Добавить("июня");
	Июнь.Добавить("июн");
	Июль = Новый Массив;
	Июль.Добавить("июль");
	Июль.Добавить("июля");
	Июль.Добавить("июл");
	Август = Новый Массив;
	Август.Добавить("август");
	Август.Добавить("августа");
	Август.Добавить("авг");
	Сентябрь = Новый Массив;
	Сентябрь.Добавить("сентябрь");
	Сентябрь.Добавить("сентября");
	Сентябрь.Добавить("сент");
	Сентябрь.Добавить("сен");
	Октябрь = Новый Массив;
	Октябрь.Добавить("октябрь");
	Октябрь.Добавить("октября");
	Октябрь.Добавить("окт");
	Ноябрь = Новый Массив;
	Ноябрь.Добавить("ноябрь");
	Ноябрь.Добавить("ноября");
	Ноябрь.Добавить("ноя");
	Ноябрь.Добавить("нояб");
	Декабрь = Новый Массив;
	Декабрь.Добавить("декабрь");
	Декабрь.Добавить("декабря");
	Декабрь.Добавить("дек");	
	
	Попытка
		НомерМесяца = Число(Мес);
	Исключение
		Если Январь.Найти(мес) <> Неопределено Тогда
			НомерМесяца = 1;
		ИначеЕсли Февраль.Найти(мес) <> Неопределено Тогда
			НомерМесяца = 2;
		ИначеЕсли Март.Найти(мес) <> Неопределено Тогда
			НомерМесяца = 3;
		ИначеЕсли Апрель.Найти(мес) <> Неопределено Тогда
			НомерМесяца = 4;
		ИначеЕсли Май.Найти(мес) <> Неопределено Тогда
			НомерМесяца = 5;
		ИначеЕсли Июнь.Найти(мес) <> Неопределено Тогда
			НомерМесяца = 6;
		ИначеЕсли Июль.Найти(мес) <> Неопределено Тогда
			НомерМесяца = 7;
		ИначеЕсли Август.Найти(мес) <> Неопределено Тогда
			НомерМесяца = 8;
		ИначеЕсли Сентябрь.Найти(мес) <> Неопределено Тогда
			НомерМесяца = 9;
		ИначеЕсли Октябрь.Найти(мес) <> Неопределено Тогда
			НомерМесяца = 10;
		ИначеЕсли Ноябрь.Найти(мес) <> Неопределено Тогда
			НомерМесяца = 11;
		ИначеЕсли Декабрь.Найти(мес) <> Неопределено Тогда
			НомерМесяца = 12;
		Иначе
			НомерМесяца = 0;
		КонецЕсли;		
	КонецПопытки;
	Возврат	НомерМесяца;
КонецФункции   //ПолучитьМесяц()

// Преобразует строку в список к возврату.
//
// Параметры:
//  Строка - строка;
//  Разделитель - разделитель - строка.
//
// Возвращаемое значение:
//   список значений.
//
Функция ПреобразоватьСтрокуВСписок(Знач Строка, Разделитель = "|") Экспорт	
	СписокКВозврату = Новый СписокЗначений;
	Строка = СтрЗаменить(Строка, Разделитель, Символы.ПС); 
	Для Ном = 1 По СтрЧислоСтрок(Строка) Цикл
		СписокКВозврату.Добавить(СтрПолучитьСтроку(Строка, Ном));
	КонецЦикла;
	Возврат СписокКВозврату;	
КонецФункции // ПреобразоватьСтрокуВСписок()

// Процедура устанавливает шаблон выдачи сообщения.
	// Параметры:
	// Ссылка - на объект из которого вызывается сообщение;
	// Текст - текст сообщения;
	// Статус -  статус сообщения.
	//
Процедура ВыдатьСообщение(Ссылка, Текст, Статус=Неопределено) Экспорт
	
	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Обычное;
	КонецЕсли;	
	
	Сообщить(Строка(Ссылка)+": "+Текст, Статус);	
	
КонецПроцедуры // ВыдатьСообщение()      
