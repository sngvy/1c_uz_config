////////////////////////////////////////////////////////////////////////////////
// Общий модуль телефонии БИТ
// Содержит общие функции, которые могут вызываться на клиенте и на сервере.
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

// Возвращает минимальную длину внешнего номера.
// Если номер длиннее данного значения, он считается внешним, иначе - внутренним.
//
// Возвращаемое значение:
//   Число - длина.
//
Функция ПолучитьДлинуВнешнегоНомера() ЭКСПОРТ
	Возврат 10;
КонецФункции

// Возвращает минимальную длину международного номера.
// Если номер длиннее данного значения, он считается международным.
//
// Международный номер в России начинается с кода "10" и имеет минимум 13 цифр,
// например: номер США 10-1 (305) 571-1200,
// номер Белоруссии 10-375 (17) 289-0000.
//
// Возвращаемое значение:
//   Число - длина.
//
Функция ПолучитьДлинуМеждународногоНомера() ЭКСПОРТ
	Возврат 13;
КонецФункции

// Получает индекс первого символа '*' или '#' в номере.
// Если символов '*' или '#' в номере нет, возвращается 0.
//
// Параметры:
//  стрНомер - Строка - номер телефона.
//
// Возвращаемое значение:
//   Целое число - индекс символа, начиная с 1.
//
Функция ПолучитьИндексЗвРеш(стрНомер) ЭКСПОРТ
	кодЗв	= 42;	// '*'
	кодРеш	= 35;	// '#'
	длинаНомера = СтрДлина(стрНомер);
	индРазд = 0;
	Для й=1 По длинаНомера Цикл
		кодСимв = КодСимвола(стрНомер, й);
		Если (кодСимв=кодЗв) ИЛИ (кодСимв=кодРеш) Тогда
			индРазд = й;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат индРазд;
КонецФункции

// Сокращает номер, убирая все префиксы.
//
// Параметры:
//  стрНомер  - Строка - номер телефона.
//
// Возвращаемое значение:
//   Строка - номер без префиксов.
//
Функция СократитьНомерДляПоиска(стрНомер) ЭКСПОРТ
	индексЗвРеш = ПолучитьИндексЗвРеш(стрНомер);
	Если индексЗвРеш > 0 Тогда
		Возврат стрНомер;
	КонецЕсли;
	//
	стрНомерДляПоиска = стрНомер;
	длинаНомера = СтрДлина(стрНомер);
	длинаВнешнегоНомера = ПолучитьДлинуВнешнегоНомера();
	Если длинаНомера > длинаВнешнегоНомера Тогда
		длинаМеждународногоНомера = ПолучитьДлинуМеждународногоНомера();
		Если длинаНомера < длинаМеждународногоНомера Тогда
			стрНомерДляПоиска = Прав(стрНомер, длинаВнешнегоНомера);
		Иначе
			индекс10 = Найти(стрНомер, "10");
			Если индекс10 > 0 Тогда
				// считаем что это международный номер
				стрНомерДляПоиска = Сред(стрНомер, индекс10);
			Иначе
				// непонятный формат номера, считаем что простой внешний
				стрНомерДляПоиска = Прав(стрНомер, длинаВнешнегоНомера);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат стрНомерДляПоиска;
КонецФункции

// Функция очистки, оставляет в строке номера только цифры от 0 до 9.
//
// Параметры:
//  стрНомер  - Строка - номер телефона.
//
// Возвращаемое значение:
//   Строка - очищенный номер.
//
Функция ОчиститьНомерТолькоЦифры(стрНомерПредставление) ЭКСПОРТ
	стрНомер = УбратьДобавочныйТелефон(стрНомерПредставление);
	код0	= 48;
	код9	= 57;
	стрОчищНомер = "";
	длинаНомера = СтрДлина(стрНомер);
	Для й=1 По длинаНомера Цикл
		кодСимв = КодСимвола(стрНомер, й);
		Если (кодСимв >= код0 И кодСимв <= код9) Тогда
			стрОчищНомер = стрОчищНомер + Символ(кодСимв);
		КонецЕсли;
	КонецЦикла;
	Возврат стрОчищНомер;
КонецФункции

// Функция очистки, оставляет в строке номера цифры от 0 до 9, символы '*' и '#'.
//
// Параметры:
//  стрНомер  - Строка - номер телефона.
//
// Возвращаемое значение:
//   Строка - очищенный номер.
//
Функция ОчиститьНомерЦифрыЗвРеш(стрНомерПредставление) ЭКСПОРТ
	стрНомер = УбратьДобавочныйТелефон(стрНомерПредставление);
	код0	= 48;	// '0'
	код9	= 57;	// '9'
	кодЗв	= 42;	// '*'
	кодРеш	= 35;	// '#'
	стрОчищНомер = "";
	длинаНомера = СтрДлина(стрНомер);
	Для й=1 По длинаНомера Цикл
		кодСимв = КодСимвола(стрНомер, й);
		Если (кодСимв >= код0 И кодСимв <= код9) ИЛИ (кодСимв=кодЗв) ИЛИ (кодСимв=кодРеш) Тогда
			стрОчищНомер = стрОчищНомер + Символ(кодСимв);
		КонецЕсли;
	КонецЦикла;
	Возврат стрОчищНомер;
КонецФункции

// Переводит длительность звонка из секунд в строку.
//
// Параметры:
//  Длительность - Число (целое), длительность в секундах.
//
// Возвращаемое значение:
//   Строка  - длительность в формате '00:00:00'.
//
Функция ФорматироватьДлительностьЗвонкаСЛидНулями(Длительность) ЭКСПОРТ
	длитМин = Цел(Длительность / 60);
	длитСек = Длительность % 60;
	длитЧас = Цел(длитМин / 60);
	длитМин = длитМин % 60;
	стрФорматаСЛидНулем = "ЧЦ=2; ЧН=; ЧВН=";
	стрДлительность = Строка(длитЧас) + ":" + Формат(длитМин, стрФорматаСЛидНулем) + ":" + Формат(длитСек, стрФорматаСЛидНулем);
	Возврат стрДлительность;
КонецФункции

// Переводит дату звонка в строку, с учетом текущей даты.
//
// Параметры:
//  датаТекущНачалоДня - Дата, начало текущего дня,
//  датаРазговора - Дата, дата-время звонка,
//
// Возвращаемое значение:
//   Строка  - дата звонка в виде '00:00:00' для сегодняшнего дня,
//     или 'вчера', или название дня недели, или день.месяц.год.
//
Функция ФорматироватьДатуРазговора(датаТекущНачалоДня, датаРазговора) ЭКСПОРТ
	разницаДат = датаТекущНачалоДня - НачалоДня(датаРазговора);
	стрДата = Строка(датаРазговора);
	Если разницаДат = 0 Тогда
		стрДата = Формат(датаРазговора, "ДЛФ=T");
	ИначеЕсли (разницаДат > 0) И (разницаДат <= 86400) Тогда
		стрДата = "вчера";
	ИначеЕсли (разницаДат > 86400) И (разницаДат <= 604800) Тогда
		стрДата = Формат(датаРазговора, "ДФ=дддд");
	Иначе
		стрДата = Формат(датаРазговора, "ДФ=dd.MM.yy");
	КонецЕсли;
	Возврат стрДата;
КонецФункции

////////////////////////////////////////////////////////////////////////////////

// Разбивает строку с разделителями, возвращает список значений.
//
// Параметры:
//  стрРазбор - Строка, строка для разбора,
//  стрРазделитель - Строка, разделитель.
//
// Возвращаемое значение:
//   СписокЗначений  - список подстрок.
//
Функция СтрРазбить(Знач стрРазбор, стрРазделитель) ЭКСПОРТ
	список = Новый СписокЗначений;
	длинаРазделителя = СтрДлина(стрРазделитель);
	поз = Найти(стрРазбор, стрРазделитель);
	Пока поз > 0 Цикл
		стрПодстрока = Лев(стрРазбор, поз-1);
		список.Добавить(стрПодстрока);
		стрРазбор = Сред(стрРазбор, поз+длинаРазделителя);
		поз = Найти(стрРазбор, стрРазделитель);
	КонецЦикла;
	Если СтрДлина(стрРазбор) <> 0 Тогда
		список.Добавить(стрРазбор);
	КонецЕсли;
	Возврат список;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с отборами динамических списков
Процедура УстановитьЭлементОтбораДинамическогоСписка(ДинамическийСписок, ИмяПоля, ПравоеЗначение) ЭКСПОРТ
	элОтбора = Неопределено;
	Для Каждого элСпискаОтбора Из ДинамическийСписок.Отбор.Элементы Цикл
		Если Строка(элСпискаОтбора.ЛевоеЗначение) = ИмяПоля Тогда
			элОтбора = элСпискаОтбора;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если элОтбора = Неопределено Тогда
		элОтбора = ДинамическийСписок.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	КонецЕсли;
	элОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	элОтбора.Использование = Истина;
	элОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	элОтбора.ПравоеЗначение = ПравоеЗначение;
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Работа с JSON

// Разбор JSON
//
// Параметры:
//   ТекстJSON - Строка - текст для разбора.
//
// Возвращаемое значение:
//   Соответствие - результат разбора.
//
Функция ЗаполнитьСоответствиеИзJSON(ТекстJSON) ЭКСПОРТ
#Если ВебКлиент Тогда
	Возврат ЗаполнитьСоответствиеИзJSONВнутр(ТекстJSON);
#Иначе
	// версия разбора для платформы 8.3.6 и выше
	чтение = Новый ЧтениеJSON();
	чтение.УстановитьСтроку(ТекстJSON);
	Результат = ПрочитатьJSON(чтение, Истина);
	Возврат Результат;
#КонецЕсли
КонецФункции

Функция ПолучитьАТСИнфоИзJSON(ТекстJSON) ЭКСПОРТ
	соотвХмл = ЗаполнитьСоответствиеИзJSON(ТекстJSON);
	Возврат ПолучитьАТСИнфоИзСоответствия(соотвХмл);
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с XML

// Разбор XML
//
// Параметры:
//   стрТекстXML - Строка - текст для разбора.
//
// Возвращаемое значение:
//   Соответствие - результат разбора.
//
Функция ЗаполнитьСоответствиеИзXML(стрТекстXML) ЭКСПОРТ
	чтение = Новый ЧтениеXML();
	чтение.УстановитьСтроку(стрТекстXML);
	дом = Новый ПостроительDOM();
	докХмл = дом.Прочитать(чтение);
	Результат = Новый Соответствие;
	ХмлВСоотв(докХмл.ПервыйДочерний, Результат);
	Возврат Результат;
КонецФункции

Функция ПолучитьАТСИнфоИзXML(стрТекстXML) ЭКСПОРТ
	соотвХмл = ЗаполнитьСоответствиеИзXML(стрТекстXML);
	Возврат ПолучитьАТСИнфоИзСоответствия(соотвХмл);
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с HTTP

// Скачивание страницы по HTTPS
//
// Параметры:
//   АдресHTTP - Строка - полный адрес страницы.
//   таймаут - целое число, время ожидания в секундах.
//   флагЗагрузкаТекста - Булево, флаг загрузки текста или двоичных данных.
//   ТелоОтвета - Строка или ДвоичныеДанные - возвращаемое значение.
//   стрОшибка - Строка - возвращаемое значение, сообщение об ошибке
//
// Возвращаемое значение:
//   Булево - успешность загрузки.
//
Функция СкачатьПоHTTPS(АдресHTTP, таймаут, флагЗагрузкаТекста, ТелоОтвета, стрОшибка) ЭКСПОРТ
#Если ВебКлиент Тогда
	// в веб-клиенте загрузка возможна только на сервере
	Возврат бит_ТелефонияСервер.СкачатьПоHTTPS(АдресHTTP, таймаут, флагЗагрузкаТекста, ТелоОтвета, стрОшибка);
#Иначе
	скачиваниеУспешно = Истина;
	Попытка
		ТелоОтвета = "";
		протокол = "";
		АдресЗагрузки = АдресHTTP;
		инд = Найти(АдресЗагрузки, "://");
		Если инд > 0 Тогда
			протокол = НРег(Лев(АдресЗагрузки, инд-1));
			АдресЗагрузки = Сред(АдресЗагрузки, инд+3);
		КонецЕсли;
		//
		СоединХост = АдресЗагрузки;
		СоединЗапрос = "";
		инд = Найти(АдресЗагрузки, "/");
		Если инд > 0 Тогда
			СоединХост = Лев(АдресЗагрузки, инд-1);
			СоединЗапрос = Сред(АдресЗагрузки, инд);
		КонецЕсли;
		//
		ssl = Неопределено;
		Если протокол = "https" Тогда
			ssl = Новый ЗащищенноеСоединениеOpenSSL;
		КонецЕсли;
		прокси = Новый ИнтернетПрокси(Ложь);
		соед = Новый HTTPСоединение(СоединХост, , , , прокси, таймаут, ssl);
		запрос = Новый HTTPЗапрос(СоединЗапрос);
		ответ = соед.Получить(запрос);
		ТелоОтвета = ? (флагЗагрузкаТекста, ответ.ПолучитьТелоКакСтроку(), ответ.ПолучитьТелоКакДвоичныеДанные());
		Если Цел(ответ.КодСостояния/100) = 2 Тогда
			скачиваниеУспешно = Истина;
		Иначе
			Если ответ.КодСостояния = 301 Тогда
				// редирект
				скачиваниеУспешно = СкачатьПоHTTPS(ответ.Заголовки["Location"], таймаут, флагЗагрузкаТекста, ТелоОтвета, стрОшибка);
			Иначе
				скачиваниеУспешно = Ложь;
				стрОшибка = "Ошибка загрузки, код " + Строка(ответ.КодСостояния);
			КонецЕсли;
		КонецЕсли;
	Исключение
		скачиваниеУспешно = Ложь;
		стрОшибка = ОписаниеОшибки();
	КонецПопытки;
	Возврат скачиваниеУспешно;
#КонецЕсли
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция УбратьДобавочныйТелефон(стрПредставлениеНомера)
	стрНомерБезДобавочного = стрПредставлениеНомера;
	индДоб = Найти(стрПредставлениеНомера, ", доб. ");
	Если индДоб > 0 Тогда
		стрНомерБезДобавочного = Лев(стрПредставлениеНомера, индДоб-1);
	КонецЕсли;
	Возврат стрНомерБезДобавочного;
КонецФункции

Функция ЗаполнитьСоответствиеИзJSONВнутр(Знач ТекстJSON)
	Результат = Новый Соответствие;
	
	ТекстJSON = СтрЗаменить(ТекстJSON, "\""", " ");
	Если Лев(ТекстJSON, 1) = "{" Тогда
		ЗаполнитьДанныеИзОтветаJSON(Результат, ТекстJSON, "Структура");
	ИначеЕсли Лев(ТекстJSON, 1) = "[" Тогда
		МассивДанных = Новый Массив;
		ЗаполнитьДанныеИзОтветаJSON(МассивДанных, ТекстJSON, "Массив");
		
		Результат.Вставить("Значение", МассивДанных);
	КонецЕсли;
		
	Возврат Результат;
КонецФункции

Функция ПолучитьТокенJSON(ТекстJSON, флагПрервать)
	
	Токен = "";
	
	Поз = Найти(ТекстJSON, """");
	Если Поз = 0 Тогда
		флагПрервать = Истина;
		Возврат Токен;
	КонецЕсли;
	
	ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз+1));
	
	Поз = Найти(ТекстJSON, """");
	Если Поз = 0 Тогда
		флагПрервать = Истина;
		Возврат Токен;
	КонецЕсли;
	
	Токен = СокрЛП(Лев(ТекстJSON, Поз-1));
	ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз+1));
	
	Возврат Токен;
КонецФункции

Функция ПолучитьЗначениеJSON(ТекстJSON, флагПрервать)
	
	ЗначениеJSON = "";
	
	Поз = Найти(ТекстJSON, """");
	Если Поз = 1 Тогда
		// значение - строка
		ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз+1));
		Поз = Найти(ТекстJSON, """");
		Если Поз = 0 Тогда
			флагПрервать = Истина;
			Возврат ЗначениеJSON;
		КонецЕсли;
		ЗначениеJSON = СокрЛП(Лев(ТекстJSON, Поз-1));
		ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз+1));
	Иначе
		ПозИст = Найти(ТекстJSON, "true");
		ПозЛож = Найти(ТекстJSON, "false");
		Если ПозИст = 1 Тогда
			ЗначениеJSON = Истина;
			ТекстJSON = СокрЛП(Сред(ТекстJSON, 5));
		ИначеЕсли ПозЛож = 1 Тогда
			ЗначениеJSON = Ложь;
			ТекстJSON = СокрЛП(Сред(ТекстJSON, 6));
		Иначе
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЗначениеJSON;
КонецФункции

Процедура ЗаполнитьДанныеИзОтветаJSON(Результат, ТекстJSON, ТипДанных)
	ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));	
	НомерЗначения = 0;
	
	Пока ТекстJSON <> "" Цикл
		ПервыйСимвол = Лев(ТекстJSON, 1);
		Если ПервыйСимвол = "{" Тогда
			Значение = Новый Соответствие;
			ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Структура");
			
			Если ТипДанных = "Структура" Тогда
				Результат.Вставить("Значение" + ?(НомерЗначения = 0, "", НомерЗначения), Значение);
				НомерЗначения = НомерЗначения + 1;
			ИначеЕсли ТипДанных = "Массив" Тогда
				Результат.Добавить(Значение);
			КонецЕсли;
		ИначеЕсли ПервыйСимвол = "[" Тогда
			Значение = Новый Массив;
			ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Массив");
			
			Если ТипДанных = "Структура" Тогда
				Результат.Вставить("Значение" + ?(НомерЗначения = 0, "", НомерЗначения), Значение);
				НомерЗначения = НомерЗначения + 1;
			Иначе
				Результат.Добавить(Значение);
			КонецЕсли;
		ИначеЕсли ПервыйСимвол = "}" И ТипДанных = "Структура" Тогда
			ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			Если Лев(ТекстJSON, 1) = "," Тогда
				ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			КонецЕсли;
			
			Возврат;
		ИначеЕсли ПервыйСимвол = "]" И ТипДанных = "Массив" Тогда
			ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			Если Лев(ТекстJSON, 1) = "," Тогда
				ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			КонецЕсли;
			
			Возврат;
		Иначе
			Если ТипДанных = "Структура" Тогда
				
				флагПрервать = Ложь;
				ИмяЗначения = ПолучитьТокенJSON(ТекстJSON, флагПрервать);
				Если флагПрервать Тогда
					Прервать;
				КонецЕсли;
				
				Поз = Найти(ТекстJSON, ":");
				Если Поз = 0 Тогда
					Прервать;
				КонецЕсли;
				
				ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз+1));
				
				Если Лев(ТекстJSON, 1) = "{" Тогда
					Значение = Новый Соответствие;
					ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Структура");
				ИначеЕсли Лев(ТекстJSON, 1) = "[" Тогда
					Значение = Новый Массив;
					ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Массив");
				Иначе
					флагПрервать = Ложь;
					Значение = ПолучитьЗначениеJSON(ТекстJSON, флагПрервать);
					
					Если флагПрервать Тогда
						Значение = ТекстJSON;
						ТекстJSON = "";
					Иначе
						Символ = Лев(ТекстJSON, 1);
						Если Символ = "," Тогда
							ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
						КонецЕсли;
					КонецЕсли;
					
				КонецЕсли;
				
				Результат.Вставить(ИмяЗначения, Значение);
				
			ИначеЕсли ТипДанных = "Массив" Тогда
				
				флагПрервать = Ложь;
				Значение = ПолучитьЗначениеJSON(ТекстJSON, флагПрервать);
				
				Если флагПрервать Тогда
					Значение = ТекстJSON;
					ТекстJSON = "";
				Иначе
					Символ = Лев(ТекстJSON, 1);
					Если Символ = "," Тогда
						ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
					КонецЕсли;
				КонецЕсли;
					
				Результат.Добавить(Значение);
				
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура ХмлВСоотв(элХмл, родитель)
	вМассив = Ложь;
	аттрМасс = элХмл.Атрибуты.ПолучитьИменованныйЭлемент("Array");
	Если аттрМасс <> Неопределено Тогда
		вМассив = (Число(аттрМасс.Значение) <> 0);
	КонецЕсли;
	вставка = Неопределено;
	Если вМассив Тогда
		вставка = Новый Массив;
		Для Каждого узХмл Из элХмл.ДочерниеУзлы Цикл
			элМасс = Новый Соответствие;
			Для Каждого аттрМассХмл Из узХмл.Атрибуты Цикл
				элМасс.Вставить(аттрМассХмл.Имя, аттрМассХмл.Значение);
			КонецЦикла;
			Для Каждого узМассХмл Из узХмл.ДочерниеУзлы Цикл
				ХмлВСоотв(узМассХмл, элМасс);
			КонецЦикла;
			вставка.Добавить(элМасс);
		КонецЦикла;
	Иначе
		вставка = Новый Соответствие();
		Для Каждого аттрХмл Из элХмл.Атрибуты Цикл
			вставка.Вставить(аттрХмл.Имя, аттрХмл.Значение);
		КонецЦикла;
		Для Каждого узХмл Из элХмл.ДочерниеУзлы Цикл
			ХмлВСоотв(узХмл, вставка);
		КонецЦикла;
	КонецЕсли;
	родитель.Вставить(элХмл.ИмяУзла, вставка);
КонецПроцедуры

Функция ПолучитьАТСИнфоИзСоответствия(соотвХмл)
	Возврат соотвХмл.Получить("PbxInfo");
КонецФункции

#КонецОбласти
